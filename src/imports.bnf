/* Lexical part */

// separator  : ',' | ':' ;
terminator : ';' '\n' | ';' | '\n' ;

/* Keywords */
kwdImport   : 'i' 'm' 'p' 'o' 'r' 't' ;
kwdPackage  : 'p' 'a' 'c' 'k' 'a' 'g' 'e' ;

/* Whitespaces (suppressed) */
!whitespace : ' ' | '\t' | '\r' ;

/* Comments (suppressed) */
!comment      : _lineComment | _blockComment ;
_lineComment  : '/' '/' { . } '\n' ;
_blockComment : '/' '*' { . | '*' } '*' '/' ;

/* Letters and digits */
_letter        : _unicodeLetter | '_' ;
_unicodeLetter : 'a' - 'z' | 'A' - 'Z' ;
_decimalDigit  : '0' - '9' ;
_octalDigit    : '0' - '7' ;
_hexDigit      : _decimalDigit | 'a' - 'f' | 'A' - 'F' ;

/* Identifiers */
// TODO: Check this
// blankIdent : '_' ;
identifier : _letter { _letter | _decimalDigit } ;

/* String literals */
stringLit          :  _rawStrLit | _interpretedStrLit ;
_rawStrLit         : '`' { . } '`' ;
_interpretedStrLit : '"' { . | '\\' '"' | _escapeChar } '"' ;
/* Single-character escapes */
_escapeChar : '\\' 'n' | '\\' 'r' | '\\' 't' ;

// Syntax part

<<
import(
        "fmt"
        "io/ioutil"
        "regexp"
        "strings"

        "gogo/tmp/token"
        "gogo/tmp/lexer"
)

type Node struct {
        place string
        code []string
}
>>

Start : SourceFile
        << func() (Attrib, error) {
	        re := regexp.MustCompile("\n(\n)*")
                c := $0.(Node).code
                for _, v := range c {
                        v := strings.TrimSpace(v)
                        // Compress multiple newlines within IR statemnets into
                        // a single newline.
                        v = re.ReplaceAllString(v, "\n")
                        if v != "" {
                                fmt.Println(v)
                        }
                }
                return nil, nil
        } () >>
      ;

// SourceFile : PackageClause terminator RepeatTerminator RepeatImportDecl RepeatTopLevelDecl
SourceFile : PackageClause terminator RepeatTerminator RepeatImportDecl
                << func() (Attrib, error) {
                        imports := strings.Split($3.(Node).place, ",")
                        for _, v := range imports {
                                fmt.Println(strings.TrimSpace(v))
                        }

                        // Try generating code for the first import.
                        f := strings.Trim(imports[0], "\"")
                        src, err := ioutil.ReadFile(f)
                        if err != nil {
                                return nil, err
                        }
                        s := lexer.NewLexer(src)
                        p := NewParser()
                        _, err = p.Parse(s)
                        if err != nil {
                                return nil, err
                        }

                        return Node{"", $3.(Node).code}, nil
                } () >>
           ;

RepeatImportDecl : ImportDecl terminator RepeatTerminator RepeatImportDecl
                        << func() (Attrib, error) {
                                n := Node{"", []string{}}
                                n.place = fmt.Sprintf("%s, %s", $0.(Node).place, $3.(Node).place)
                                // n.code = append(n.code, $0.(Node).code...)
                                // n.code = append(n.code, $3.(Node).code...)
                                // n.code = append(n.code, "\n")
                                return n, nil
                        } () >>
                 | empty
                        << func() (Attrib, error) {
                                n := Node{"", []string{}}
                                return n, nil
                        } () >>
                 ;

// ImportDecl       = "import" ( ImportSpec | "(" { ImportSpec ";" } ")" ) .
// ImportSpec       = [ "." | PackageName ] ImportPath .
// ImportPath       = string_lit .
ImportDecl : kwdImport ImportSpec
                << func() (Attrib, error) {
                        return Node{$1.(Node).place, []string{}}, nil
                } () >>
           | kwdImport "(" RepeatImportSpec ")"
                << func() (Attrib, error) {
                        return Node{$1.(Node).place, []string{}}, nil
                } () >>
           ;

RepeatImportSpec : ImportSpec terminator RepeatImportSpec
                << func() (Attrib, error) {
                        return Node{fmt.Sprintf("%s, %s", $0.(Node).place, $2.(Node).place), []string{}}, nil
                } () >>
                 | empty
                << func() (Attrib, error) {
                        return Node{"", []string{}}, nil
                } () >>
//                 // TODO: '\n' can follow "import (", but a ';' cannot as opposed to go's grammar.
//                  | terminator RepeatImportSpec
//                 << func() (Attrib, error) {
//                         fmt.Println("terminator RepeatImportSpec");
//                         return nil, nil
//                 } () >>
                 ;

ImportSpec : ImportPath
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, []string{}}, nil
                } () >>
//            | "." ImportPath
//                 << func() (Attrib, error) {
//                         fmt.Println("\".\" ImportPath");
//                         return nil, nil
//                 } () >>
//            | PackageName ImportPath
//                 << func() (Attrib, error) {
//                         fmt.Println("PackageName ImportPath");
//                         return nil, nil
//                 } () >>
           ;

ImportPath : stringLit
                << func() (Attrib, error) {
                        return Node{string($0.(*token.Token).Lit), []string{}}, nil
                } () >>
           ;

PackageClause : kwdPackage PackageName
                << func() (Attrib, error) {
                        return Node{$1.(Node).place, []string{}}, nil
                } () >>
              ;

PackageName : identifier
                << func() (Attrib, error) {
                        return Node{string($0.(*token.Token).Lit), []string{}}, nil
                } () >>
            ;

RepeatTerminator : terminator RepeatTerminator
                << func() (Attrib, error) {
                      return nil, nil
                } () >>
                 | empty
                << func() (Attrib, error) {
                      return nil, nil
                } () >>
                 ;
